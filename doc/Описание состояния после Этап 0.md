# MyIS — отчёт о состоянии системы после Этапа 0

## 1. Общее описание системы

MyIS — многослойная информационная система для управления производственными и операционными процессами предприятия. В соответствии с концепцией (Этап 0, Приложение В) система ориентирована на следующие домены:

- Requests (заявки / заказы)
- Customers (клиенты)
- Procurement (закупки)
- Production (производство)
- Warehouse (склад)
- Engineering (конструкторская деятельность)
- Technology (технологические процессы)

На Этапе 0 основной фокус был на создании **каркаса системы**, а не на полной предметной логике. В рамках этого каркаса реализованы:

- базовая архитектура backend’а (.NET 8, ASP.NET Core Web API + PostgreSQL + EF Core 8);
- архитектура фронтенда (React 18 + TypeScript 5 + Vite + Ant Design 5 + React Router v6);
- управляемая диагностика и конфигурация подключения к БД (DB Setup);
- базовая аутентификация и авторизация (логин Admin/admin, роль ADMIN, защита маршрутов);
- тестовая инфраструктура и сценарии локального запуска (включая работу по IP внутри локальной сети).

Система уже может:

- стартовать даже при отсутствии или поломке БД;
- через web‑интерфейс настраивать строку подключения и применять EF‑миграции;
- автоматически создавать администратора и входить под ним;
- запускаться в режиме разработки единым скриптом с авто‑перезапуском backend’а и HMR на фронте.

---

## 2. Архитектура backend

### 2.1. Проекты и слои

Решение `MyIS.sln` содержит следующие ключевые проекты:

1. **MyIS.Core.Domain**  
   - Доменный слой (чистые сущности и value‑объекты).
   - В частности, сущности пользователей и ролей:
     - `Users/User.cs` — `User`
     - `Users/Role.cs` — `Role`
     - `Users/UserRole.cs` — `UserRole`

2. **MyIS.Core.Application**  
   - Прикладной слой, контракты бизнес‑логики.
   - Интерфейсы авторизации:
     - `Auth/IAuthService.cs` — контракт сервиса аутентификации.
     - `Auth/IPasswordHasher.cs` — контракт хеширования паролей.
   - DTO результата логина:
     - `Auth/AuthResult.cs`.

3. **MyIS.Core.Infrastructure**  
   - Реализация прикладных интерфейсов и инфраструктурные детали:
     - Реализация аутентификации:
       - `Auth/AuthService.cs` — реализация `IAuthService`, работающая через EF Core и доменные сущности.
       - `Auth/BcryptPasswordHasher.cs` — реализация `IPasswordHasher` на основе BCrypt.Net-Next.
     - Доступ к данным:
       - `Data/AppDbContext.cs` — DbContext для PostgreSQL.
       - Конфигурации EF Core:
         - `Data/Configurations/UserConfiguration.cs`
         - `Data/Configurations/RoleConfiguration.cs`
         - `Data/Configurations/UserRoleConfiguration.cs`
     - Инфраструктурные расширения:
       - `DependencyInjection/ServiceCollectionExtensions.cs` — DI‑регистрация инфраструктуры.
       - `DependencyInjection/DatabaseSeeder.cs` — старый runtime‑сидер (больше не используется).

4. **MyIS.Core.WebApi**  
   - Слой Web API на ASP.NET Core.
   - Точка входа:
     - `Program.cs` — создание `WebApplication`, настройка конфигурации, DI, CORS, middleware и маршрутизации.
   - Конфигурация:
     - `appsettings.json`, `appsettings.Development.json`, а также поддержка override‑файла `appsettings.Local.json`.
   - Контроллеры:
     - `Controllers/AdminDbController.cs` — Admin DB API.
     - `Controllers/AuthController.cs` — авторизация (login / me / logout).

Связи между слоями:

- WebApi зависит от Application и Infrastructure.
- Infrastructure зависит от Domain и Application.
- Domain не зависит от других слоёв.

### 2.2. Подключение к БД и диагностика

Подключение к БД и диагностика реализованы через набор типов в `Core.Infrastructure/Data`:

- `ConnectionStringSource.cs` — enum источника строки подключения (`None`, `AppSettingsLocal`, `Configuration` и т.д.).
- `ConnectionStringResult.cs` — результат получения строки подключения (`IsConfigured`, `ConnectionString`, `Source`, `RawSourceDescription`).
- `IConnectionStringProvider.cs` — интерфейс провайдера строки подключения.
- `DefaultConnectionStringProvider.cs` — реализация провайдера:
  - приоритет:
    1. `appsettings.Local.json` (`ConnectionStrings:Default` в `ContentRootPath`),
    2. `IConfiguration.GetConnectionString("Default")` (стандартные источники конфигурации).
  - провайдер **не бросает исключений** при ошибке чтения/отсутствии строки, а возвращает `IsConfigured = false` с диагностическим описанием.
- `DbConnectionStatus.cs` — DTO для состояния подключения к БД (`Configured`, `CanConnect`, `LastError`, `Environment`, `ConnectionStringSource`, `RawSourceDescription`).
- `IDbHealthService.cs` / `DbHealthService.cs` — сервис проверки доступности БД:
  - вызывает `IConnectionStringProvider.GetDefaultConnection()`;
  - при отсутствии строки — возвращает `Configured = false`, `CanConnect = false`;
  - при наличии строки — пробует открыть `NpgsqlConnection`:
    - при успехе: `CanConnect = true`;
    - при ошибке: не кидает исключений наружу, логирует через `ILogger`, возвращает `CanConnect = false` и `LastError = ex.Message`.

Регистрация в `Program.cs`:

- Добавление `appsettings.Local.json`:

```csharp
builder.Configuration.AddJsonFile(
    "appsettings.Local.json",
    optional: true,
    reloadOnChange: true);
```

- Регистрация сервисов:

```csharp
builder.Services.AddSingleton<IConnectionStringProvider, DefaultConnectionStringProvider>();
builder.Services.AddScoped<IDbHealthService, DbHealthService>();
```

- Регистрация `AppDbContext` через `IConnectionStringProvider`:

```csharp
builder.Services.AddDbContext<AppDbContext>((sp, options) =>
{
    var provider = sp.GetRequiredService<IConnectionStringProvider>();
    var result = provider.GetDefaultConnection();

    if (!result.IsConfigured || string.IsNullOrWhiteSpace(result.ConnectionString))
    {
        // Контекст не конфигурируется, приложение при этом стартует
        return;
    }

    options.UseNpgsql(result.ConnectionString);
});
```

Таким образом, Web API может стартовать даже без настроенной строки подключения и предоставить средства её настройки через Admin DB API.

### 2.3. Admin DB API

Контроллер `AdminDbController` реализует административные эндпоинты для диагностики и настройки подключения к БД.

#### Эндпоинты

1. **GET `/api/admin/db-status`**

- Вызывает `IDbHealthService.CheckConnectionAsync`.
- Возвращает `DbConnectionStatus`:
  - `Configured` — есть ли строка подключения;
  - `CanConnect` — удаётся ли подключиться;
  - `LastError` — текст ошибки (без секретов);
  - `Environment` — имя окружения;
  - `ConnectionStringSource`, `RawSourceDescription`.
- Не выбрасывает необработанных исключений: все ошибки закодированы в полях ответа.

2. **POST `/api/admin/db-config/test`**

- Принимает JSON с параметрами подключения (`DbConnectionConfigRequest`: host, port, database, username, password, SSL и т.п.).
- Собирает временную строку подключения (без изменения конфигурации приложения).
- Пытается открыть соединение к PostgreSQL:
  - При успехе: `CanConnect = true`, `LastError = null`.
  - При ошибке: `CanConnect = false`, `LastError = ex.Message`, логирует предупреждение.
- Возвращает `DbConnectionTestResponse` с безопасной информацией (`SafeConnectionInfo` без пароля).

3. **POST `/api/admin/db-config/apply`**

- Доступен только в окружении `Development`:
  - в других окружениях возвращает `403 Forbidden`.
- В Dev:
  1. Принимает `DbConnectionConfigRequest`.
  2. Формирует строку подключения и записывает её в `appsettings.Local.json` (секция `ConnectionStrings:Default`).
  3. Проверяет подключение к новой БД.
  4. Создаёт новый scope, резолвит `AppDbContext`, вызывает `Database.MigrateAsync` — применяет все EF‑миграции к новой БД.
  5. Возвращает `DbConnectionApplyResponse` с флагами:
     - `Applied` — строка успешно сохранена в Local;
     - `CanConnect` — удалось ли подключиться к новой БД;
     - `MigrationsApplied` — удалось ли применить миграции;
     - `LastError` — текст последней ошибки (если есть).

---

## 3. Архитектура frontend

### 3.1. Технологический стек

Фронтенд реализован в папке `frontend` на основе:

- React 18;
- TypeScript 5;
- Vite (dev‑сервер и сборщик);
- Ant Design 5;
- React Router v6.

Конфигурация Vite:

- Dev‑сервер слушает `0.0.0.0:5173` (доступен по IP внутри LAN).
- Proxy `/api/*` перенаправляет запросы на backend (обычно `http://localhost:5000`), что:
  - избавляет от CORS в dev‑режиме;
  - позволяет фронту использовать относительные пути `/api/...`.

### 3.2. Каркас приложения (AppShell и маршрутизация)

Каркас (AppShell):

- Использует `Layout` из Ant Design:
  - `Header` — название системы, placeholder под информацию о текущем пользователе.
  - `Sider` — меню доменов (Requests, Customers, Procurement, Production, Warehouse, Engineering, Technology) с возможностью сворачивания.
  - `Content` — слот для вложенных страниц (через `<Outlet />` React Router).
- AppShell применяется как оболочка для **приватной части** приложения (после авторизации).

Маршрутизация:

- Публичные маршруты (без AppShell):
  - `/login` — страница логина.
  - `/db-setup` — страница настройки БД.
- Приватные маршруты:
  - Обёртка: `<DbStatusGuard><RequireAuth><AppShell>...</AppShell></RequireAuth></DbStatusGuard>`:
    - `DbStatusGuard` сначала проверяет состояние БД через `/api/admin/db-status`:
      - при `configured=false` или `canConnect=false` → редирект на `/db-setup`;
      - при OK → пропускает дальше.
    - `RequireAuth` проверяет наличие пользователя в контексте:
      - при отсутствии пользователя вызывает `/api/auth/me`;
      - при 200 — восстанавливает пользователя и рендерит контент;
      - при 401 — редиректит на `/login`.
    - AppShell рендерит основной UI и вложенные роуты доменов.

### 3.3. Страница DB Setup (`/db-setup`)

Функциональность:

- При загрузке страницы:
  - отправляет `GET /api/admin/db-status`;
  - показывает текущий статус БД (`configured`, `canConnect`, `LastError` и др.).
- Форма Ant Design с полями:
  - `host`, `port`, `database`, `username`, `password`, `runMigrations`.
- Кнопка «Проверить подключение»:
  - `POST /api/admin/db-config/test` с параметрами формы;
  - результат отображается пользователю (успех/ошибка).
- Кнопка «Сохранить и применить»:
  - доступна при успешной проверке;
  - `POST /api/admin/db-config/apply`;
  - при успехе:
    - строка сохраняется в `appsettings.Local.json` на backend’е;
    - запускаются миграции EF Core;
    - фронт делает редирект на `/login`.
- Обработка ошибок:
  - 403 (в non‑dev окружении) отображается как понятное сообщение («операция запрещена»);
  - сетевые/общие ошибки отображаются через Ant Design компоненты (например, `message` или `Alert`).

### 3.4. Страница Login и AuthContext

Страница `/login`:

- Анкетная форма AntD с полями:
  - `login`, `password`.
- При отправке:
  - `POST /api/auth/login`.
  - При успехе:
    - сохраняет информацию о пользователе в `AuthContext` (минимум id, login, roles);
    - перенаправляет на `/` или на исходный защищённый маршрут.
  - При ошибках:
    - 401 → «Неверный логин или пароль»;
    - 403 → «Учётная запись заблокирована»;
    - другие статусы → общее или техническое сообщение.

AuthContext:

- Хранит текущее состояние аутентификации:
  - объект пользователя,
  - флаг инициализации/загрузки,
  - методы `login`, `logout`, `refreshMe`.
- Хук `useAuth` упрощает доступ к контексту.

RequireAuth:

- Если пользователь уже есть в AuthContext:
  - сразу рендерит детей (AppShell + содержимое).
- Если пользователя нет:
  - вызывает `GET /api/auth/me`:
    - при 200 — сохраняет пользователя в контекст;
    - при 401 — редиректит на `/login`.
  - Пока запрос выполняется, показывает экран загрузки (скелетон/спиннер), а не мгновенный редирект.

---

## 4. Аутентификация и авторизация

### 4.1. Backend

- `AuthService` реализует логику аутентификации через EF Core:
  - поиск пользователя по логину,
  - проверка bcrypt‑хэша пароля,
  - проверка активности учётной записи.
- `AuthController` реализует API:
  - `POST /api/auth/login`:
    - валидирует учётные данные,
    - при успехе:
      - формирует `AuthResult` (id, login, roles и т.п.),
      - логирует успешный вход (`User <guid> logged in successfully.`),
      - возвращает 200 с нужными данными/токеном/кукой.
    - ошибки:
      - 401 — неверные креды;
      - 403 — учётная запись заблокирована.
  - `GET /api/auth/me`:
    - при действующей сессии возвращает текущего пользователя;
    - при отсутствии — 401.
  - `POST /api/auth/logout`:
    - завершает сессию,
    - логирует выход (`User <guid> logged out.`).

Роль `ADMIN` создаётся миграцией (см. следующий раздел). Она используется для разграничения прав (доступ к админским функциям, настройкам и т.д.).

### 4.2. Frontend

- Состояние пользователя и ролей хранится в AuthContext.
- После успешного `login` контекст обновляется, и UI рендерится с учётом аутентифицированного состояния.
- При заходе на защищённые маршруты:
  - DbStatusGuard проверяет состояние БД.
  - RequireAuth проверяет/восстанавливает сессию (`/api/auth/me`).
  - Роль `ADMIN` может использоваться для условного отображения элементов UI.

---

## 5. Автоматическое создание администратора через EF‑миграции

Сидер администратора реализован через EF‑миграцию:

- `Core.Infrastructure/Migrations/20251210075627_SeedAdminUser.cs`

В `Up` миграции:

- Гарантируется наличие:
  - расширения `uuid-ossp`,
  - схемы `core`.
- Создаются таблицы:
  - `core.roles`,
  - `core.users`,
  - `core.user_roles`.
- Выполняются сидирующие вставки с проверкой `WHERE NOT EXISTS`:
  - Роль `ADMIN`:
    - `id = 11111111-1111-1111-1111-111111111111`
    - `code = 'ADMIN'`
    - `name = 'Administrator'`
  - Пользователь `Admin`:
    - `id = 22222222-2222-2222-2222-222222222222`
    - `login = 'Admin'`
    - `full_name = 'Administrator'`
    - `is_active = TRUE`
    - `password_hash` — bcrypt‑хэш пароля `admin`, совместимый с `BcryptPasswordHasher`.
  - Связь user–role в `core.user_roles`:
    - `user_id = 22222222-2222-2222-2222-222222222222`
    - `role_id = 11111111-1111-1111-1111-111111111111`.

В `Down` миграции:

- Удаляется связь `user_roles` по указанным ID.
- Удаляются пользователь и роль.
- Дальнейший откат может дропать таблицы.

Ограничения и предпосылки:

- Используются фиксированные GUID’ы, что упрощает повторные применения миграций и их откат.
- Хэш пароля `admin` должен оставаться согласованным с реализацией `BcryptPasswordHasher`.
- При накатывании миграций на prod‑окружение такой сидер создаст Admin/admin, поэтому на следующих этапах нужно предусмотреть:
  - смену пароля администратора;
  - отдельный механизм первичной инициализации для prod.

---

## 6. Тестовая инфраструктура

Создан тестовый проект:

- `backend/tests/Core.Infrastructure.Tests/MyIS.Core.Infrastructure.Tests.csproj` (xUnit, .NET 8).

Основной тестовый файл:

- `backend/tests/Core.Infrastructure.Tests/UnitTest1.cs`

Тестируется:

1. **DefaultConnectionStringProvider**:
   - приоритезация `appsettings.Local.json` над стандартной конфигурацией;
   - корректная работа при отсутствии строки подключения (без исключений, с диагностикой).

2. **DbHealthService**:
   - поведение при отсутствии строки подключения:
     - `Configured = false`, `CanConnect = false`, осмысленный `LastError`;
   - поведение при нерабочей строке:
     - `Configured = true`, `CanConnect = false`, заполненный `LastError`, отсутствие выброса исключений.

Запуск тестов:

```cmd
cd /d d:\MyIS
dotnet test MyIS.sln
```

На текущем этапе все тесты проходят успешно.

Интеграционные тесты WebApi, фронтовые unit/компонентные тесты и e2e‑тесты пока отсутствуют, но логически являются следующими шагами развития тестовой инфраструктуры.

---

## 7. Конфигурация разработки и запуск с нуля

### 7.1. Требования к окружению

- .NET SDK 8+
- Node.js 18+ (npm)
- PostgreSQL
- Git

### 7.2. Развёртывание с нуля

Краткий конспект из `DEV_SETUP.md`:

1. Клонировать репозиторий:

```cmd
cd /d d:\
git clone <URL_репозитория> MyIS
cd MyIS
```

2. Установить зависимости frontend:

```cmd
cd /d d:\MyIS\frontend
npm install
```

3. Применить миграции БД:

```cmd
cd /d d:\MyIS
dotnet ef database update --project backend/src/Core.Infrastructure/MyIS.Core.Infrastructure.csproj --startup-project backend/src/Core.WebApi/MyIS.Core.WebApi.csproj
```

4. Открыть порты для LAN (5000 — backend, 5173 — frontend):

```cmd
netsh advfirewall firewall add rule name="MyIS Backend 5000" dir=in action=allow protocol=TCP localport=5000
netsh advfirewall firewall add rule name="MyIS Frontend 5173" dir=in action=allow protocol=TCP localport=5173
```

### 7.3. Запуск dev‑стенда

Используется скрипт `dev.cmd` в корне:

```cmd
cd /d d:\MyIS
dev.cmd
```

Скрипт:

- поднимает WebApi (`dotnet watch run`) на `http://0.0.0.0:5000`;
- поднимает Vite dev server (`npm run dev`) на `http://0.0.0.0:5173`.

### 7.4. Доступ и первый вход

- Локально:
  - фронт: `http://localhost:5173/`
  - проверка статуса БД: `http://localhost:5000/api/admin/db-status`
- По LAN (пример IP `192.168.0.10`):
  - фронт: `http://192.168.0.10:5173/`
  - API: `http://192.168.0.10:5000/api/admin/db-status`

Первый вход:

- Пользователь: `Admin`
- Пароль: `admin`
- При успехе:
  - backend пишет в лог `User <guid> logged in successfully.`;
  - фронтенд переводит пользователя в защищённую зону (AppShell).

При необходимости смены БД:

- перейти на `/db-setup` (автоматически или вручную);
- использовать:
  - `GET /api/admin/db-status` → отображение текущего состояния;
  - `POST /api/admin/db-config/test` → проверка новой строки;
  - `POST /api/admin/db-config/apply` → сохранение строки в `appsettings.Local.json` и выполнение миграций.

---

## 8. Текущий статус, ограничения и направления развития (для Этапа 1)

### 8.1. Реализовано и стабильно работает

- Каркас backend’а:
  - инфраструктура подключения к БД посредством `IConnectionStringProvider` и `DbHealthService`;
  - Admin DB API (`db-status`, `db-config/test`, `db-config/apply`);
  - автоматический сид администратора через EF‑миграции (Admin/admin, роль ADMIN и связь);
  - базовая авторизация (`/api/auth/login`, `/api/auth/me`, `/api/auth/logout`).

- Каркас фронтенда:
  - AppShell с Ant Design Layout и меню доменов;
  - страницы Login и DB Setup;
  - Guards:
    - DbStatusGuard (проверка состояния БД);
    - RequireAuth (проверка сессии и редиректы на логин).

- Тестовая инфраструктура:
  - юнит‑тесты для ключевых инфраструктурных сервисов (провайдер строки и health‑сервис);
  - `dotnet test MyIS.sln` проходит успешно.

- Dev‑процесс:
  - единый скрипт `dev.cmd` для запуска backend + frontend с авто‑перезапуском;
  - `DEV_SETUP.md` с инструкцией по развёртыванию на новой машине.

### 8.2. Ограничения и технический долг

- Нет интеграционных тестов WebApi и фронтенд‑тестов (Vitest/Jest, e2e).
- Продакшен‑конфигурация (HTTPS, reverse proxy, деплой, управление секретами) не описана.
- Механизмы авторизации по ролям и разграничение прав пока в зачаточном состоянии (есть только роль ADMIN и базовая auth‑логика).
- Обработка ошибок на фронте только частично централизована (Login, DbSetup); общий error‑handling слой можно усиливать.

### 8.3. Рекомендации для Этапа 1

Предлагаемые направления развития:

1. **Функциональное развитие после логина**  
   Реализовать первые доменные сценарии (например, Requests/Customers) на базе готового каркаса (AppShell, Auth, DbStatusGuard).

2. **Развитие авторизации**  
   Ввести role‑based и policy‑based авторизацию на backend’е и соответственное управление доступом на фронте.

3. **Усиление тестового покрытия**  
   Добавить интеграционные тесты WebApi, фронтенд‑тесты для guard’ов и страниц, а также базовые e2e‑сценарии.

4. **Улучшение UX DB Setup**  
   Расширить валидацию, сообщения об ошибках, подсказки, логгирование и диагностику.

5. **Безопасность и конфигурация окружений**  
   Описать и внедрить prod‑сценарий с безопасным управлением секретами и учётными записями, включая безопасную работу с администратором.