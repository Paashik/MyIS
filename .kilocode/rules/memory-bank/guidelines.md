# Guidelines для ИИ в проекте MyIS

Этот файл описывает, как ИИ должен работать с репозиторием MyIS, какие источники считать нормативными и какие ограничения соблюдать.

## 1. Приоритеты источников знаний

1. Для общего понимания системы:
   - [`brief.md`](.kilocode/rules/memory-bank/brief.md);
   - [`00_Концепция_системы.md`](Doc/00_Концепция_системы.md);
   - [`Описание состояния после Этап 0.md`](Doc/Описание состояния после Этап 0.md).

2. Для архитектурных правил:
   - [`architecture.md`](.kilocode/rules/memory-bank/architecture.md);
   - [`Coding_Guidelines_MyIS.md`](.kilocode/rules/Coding_Guidelines_MyIS.md);
   - [`MyIS_Architecture_Core_Requirements.md`](.kilocode/rules/MyIS_Architecture_Core_Requirements.md).

3. Для технологических деталей:
   - [`tech.md`](.kilocode/rules/memory-bank/tech.md);
   - [`10_ТЗ_Этап0_Каркас_системы.md`](Doc/10_ТЗ_Этап0_Каркас_системы.md);
   - [`11_Приложение_В_Каркас_интерфейса_Этап0.md`](Doc/11_Приложение_В_Каркас_интерфейса_Этап0.md);
   - [`12_Приложение_Г_Модель_данных_users_roles_Этап0.md`](Doc/12_Приложение_Г_Модель_данных_users_roles_Этап0.md);
   - [`13_Приложение_Д_API_Login_Auth_Этап0.md`](Doc/13_Приложение_Д_API_Login_Auth_Этап0.md);
   - [`14_Приложение_Е_Структура_репозитория_Git_Этап0.md`](Doc/14_Приложение_Е_Структура_репозитория_Git_Этап0.md);
   - [`15_Приложение_Ж_Требования_CI_CD_Этап0.md`](Doc/15_Приложение_Ж_Требования_CI_CD_Этап0.md).

4. Для доменных требований по Requests и последующим этапам:
   - [`01_Бизнес-процессы.md`](Doc/01_Бизнес-процессы.md);
   - [`20_ТЗ_Этап1_Requests.md`](Doc/20_ТЗ_Этап1_Requests.md);
   - будущие ТЗ и модели данных (при появлении в `Doc/`).

Правило: новые решения не должны противоречить концепции и ТЗ Этапов 0 и 1, а также установленным архитектурным правилам в `.kilocode/rules`.

## 2. Общий алгоритм работы ИИ

Перед любыми изменениями кода ИИ должен:

1. Определить слой:
   - Domain / Application / Infrastructure / WebApi / Frontend.

2. Определить доменный модуль:
   - Requests, Customers, Procurement, Production, Warehouse, Engineering, Technology, Integration.Component2020, Auth/Users.

3. Проверить существующие элементы:
   - сущности и Value Objects в Domain;
   - Use Case (Handlers) и DTO в Application;
   - репозитории и интеграции в Infrastructure;
   - контроллеры и маршруты в WebApi;
   - страницы, хуки и API‑клиенты на фронте.

4. Сопоставить задачу с этапностью:
   - сейчас реализован каркас Этапа 0 (Auth, DB Setup, App Shell);
   - функциональность Requests и других доменов должна реализовываться в соответствии c [`20_ТЗ_Этап1_Requests.md`](Doc/20_ТЗ_Этап1_Requests.md) и концепцией.

5. Спроектировать изменения:
   - учесть модульные границы и владение данными;
   - подобрать корректные имена классов и DTO по [`Coding_Guidelines_MyIS.md`](.kilocode/rules/Coding_Guidelines_MyIS.md).

6. Только после этого вносить правки в код.

## 3. Жёсткие запреты

ИИ не должен:

- добавлять бизнес‑логику:
  - в Infrastructure (репозитории, миграции, интеграции);
  - в WebApi (контроллеры);
  - во Frontend (React‑компоненты, хуки, маршруты);
- обходить модульные границы:
  - любые прямые SQL/EF‑запросы к «чужим» таблицам другого домена;
  - прямой доступ к Компонент‑2020 из Domain/Application;
- нарушать слои:
  - размещать DTO или API‑модели в Domain;
  - использовать EF Core‑типы в Domain/Application;
  - тянуть HTTP/файловые зависимости в Domain;
- проверять роли на фронте напрямую (например, `roles.includes("ADMIN")`) вместо абстракций прав:
  - должен использоваться слой прав с `can(permission)` (RBAC‑модель будет развиваться, но прямой доступ к ролям в UI считается техническим долгом).

При сомнении нужно предпочесть более строгую интерпретацию правил и ссылаться на [`Coding_Guidelines_MyIS.md`](.kilocode/rules/Coding_Guidelines_MyIS.md) и [`MyIS_Architecture_Core_Requirements.md`](.kilocode/rules/MyIS_Architecture_Core_Requirements.md).

## 4. Шаблоны и best practices для генерации кода

### 4.1. Создание новых Use Case

При добавлении Use Case:

- в Application:
  - создать DTO `SomethingCommand` или `SomethingQuery`;
  - создать Handler `SomethingHandler` (CommandHandler или QueryHandler);
  - внедрить необходимые репозитории и сервисы через интерфейсы;
  - реализовать бизнес‑логику через доменные сущности и сервисы;
- в Domain:
  - при необходимости добавить сущности, VO и методы, соблюдая инварианты;
  - не использовать EF/HTTP/файлы;
- в Infrastructure:
  - реализовать новые репозитории, маппинги и, при необходимости, миграции.

### 4.2. Расширение WebApi

- добавлять контроллеры и методы:
  - только как тонкую оболочку над Use Case;
  - с чёткими моделями запросов/ответов (DTO);
  - без бизнес‑логики в методах контроллера.

### 4.3. Расширение фронтенда

- новые страницы должны:
  - встраиваться в App Shell и маршрутизацию;
  - использовать Ant Design‑компоненты и общий стиль;
  - получать данные только через API‑клиенты к REST API;
- guard’ы (`DbStatusGuard`, `RequireAuth`) должны использоваться для всех приватных маршрутов;
- UI не должен содержать бизнес‑правила, которые принадлежат серверу.

## 5. Стиль ответов и кода ИИ

При работе в этом репозитории ИИ должен:

- отвечать на **русском** языке, технически и сжато;
- сначала давать краткий контекст, затем план действий, затем конкретные изменения;
- при ссылках на код и файлы использовать кликабельные ссылки формата:
  - [`Program.cs`](backend/src/Core.WebApi/Program.cs:1) для файлов;
  - [`AuthService`](backend/src/Core.Infrastructure/Auth/AuthService.cs:11) для конструкций языка;
- учитывать ограничение контекста:
  - не вставлять большие фрагменты документов из Doc и `.kilocode/rules`, если достаточно краткой ссылки/конспекта;
  - использовать memory bank как основу для понимания, а не дублировать его содержимое в каждом ответе.

ИИ обязан всегда проверять, не противоречат ли предлагаемые изменения:

- архитектурным правилам памяти (этот файл и [`architecture.md`](.kilocode/rules/memory-bank/architecture.md));
- нормативам в `.kilocode/rules/*`;
- концепции и ТЗ в папке `Doc/`.

Если противоречие неизбежно из‑за прямой инструкции пользователя, ИИ должен явно указать на это в ответе и по возможности предложить компромиссное решение, минимизирующее архитектурные нарушения.

## 6. Локализация UI (RU по умолчанию) и устойчивые автотесты

Эти правила нужны, чтобы UI был единообразно русскоязычным по умолчанию, а тесты и проверки не ломались при правках формулировок.

### 6.1. Язык интерфейса по умолчанию

- **RU (ru-RU) — default locale** для пользовательского интерфейса.
- Любые новые экранные тексты (заголовки, подписи полей, кнопки, ошибки, уведомления) должны иметь русскую версию как базовую.
- Английский допускается в:
  - именах классов/типов/переменных;
  - кодах/ключах/идентификаторах (например, i18n keys);
  - технических логах/диагностике.

### 6.2. Рекомендуемый паттерн централизованной локализации (RU)

Рекомендуемый минимум для фронтенда:

- единый словарь RU (например, `frontend/src/core/i18n/ru.ts`) — **single source of truth** для всех русских строк;
- хелпер `t(key)` для получения строки по ключу (плюс интерполяция параметров при необходимости);
- ключи локализации **стабильны** (меняется значение RU-строки, но не ключ);
- все изменения пользовательских русских формулировок делаются **в одном месте** — в RU-словаре.

Цель: менять формулировки без каскадных правок по коду/тестам.

### 6.3. Требования к тестам и проверкам (антихрупкость)

Тесты (unit/integration/e2e) и любые автоматические проверки UI **не должны**:

- искать элементы по отображаемому тексту (лейблы, тексты кнопок, тосты, тексты ошибок);
- делать assertions по «голым» строкам, размазанным по тестам.

Допустимые, устойчивые опоры для поиска/проверок (в порядке предпочтения):

1) `data-testid` на ключевых интерактивных элементах и важных точках проверки (кнопки, input/select, модальные окна, уведомления).
2) `role` + устойчивый селектор/атрибут (например, `name` у полей форм, `id`, контролируемая структура DOM), **без привязки к локализованному отображаемому тексту**.
3) `aria-label` / `aria-labelledby` — только если значение не становится «хрупким» (например, строится из i18n-ключей или стабильно задано проектом).
4) URL/route (переходы, редиректы, параметры URL), а также структура DOM как крайний случай.

Если в UI нет `data-testid` там, где без него тест получается хрупким — рекомендуется **минимально инвазивно добавить** `data-testid` только в нужные элементы, а не строить тест на тексте.

Допущение (только когда реально нужно сравнить/использовать отображаемый текст):

- сравнение текста/поиск по тексту разрешено **только через централизованный RU-словарь/ключи i18n**, чтобы изменение формулировки происходило в одном месте и не превращало тесты в «ловушки на тексте».
