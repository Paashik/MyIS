
# Правила проектирования кода MyIS  
*Версия 2.0 — унифицирована для документации и использования ИИ*

## 1. Назначение документа
Этот документ является обязательным нормативом для разработки MyIS.  
Он предназначен для:
- **разработчиков**, чтобы писать код единообразно, предсказуемо и масштабируемо;
- **ИИ‑генераторов кода**, чтобы создавать корректные сущности, use case’ы, DTO, API и структуры каталогов.

Документ описывает правила:
- архитектурного устройства,
- того, какие виды объектов существуют,
- как они должны выглядеть,
- где и что разрешено/запрещено писать.

---

## 2. Термины

### 2.1. Use Case (Application Service)
Use Case — *завершённая бизнес-операция системы*.

Примеры:
- регистрация прихода на склад,  
- формирование печатной формы отчёта,  
- создание спецификации изделия,  
- согласование заявки,  
- расчёт себестоимости,  
- импорт структуры изделия,  
- изменение прав пользователя.

Use Case:
- имеет входной DTO (Command/Query),
- вызывает доменные сущности и доменные сервисы,
- выполняется в транзакции,
- возвращает результат (Response DTO),
- является единственным местом изменения состояния системы.

### 2.2. Прочие термины
- **Entity** — доменная сущность с идентичностью.
- **Value Object** — неизменяемый объект значения.
- **Domain Service** — бизнес‑операция, не принадлежащая одной сущности.
- **Repository** — интерфейс доступа к данным.
- **DTO** — структура данных для обмена между слоями.
- **Module / Bounded Context** — независимая предметная область (Requests, Warehouse, PDM, Reporting и др.).

---

## 3. Правила проектирования по слоям

---

# 3.1. Domain Layer (MyIS.Core.Domain)

### Обязательно
1. Domain содержит:
   - Entities,
   - Value Objects,
   - Domain Services и доменные события.
2. Entities должны содержать инварианты и бизнес‑логику.
3. Value Objects должны использоваться для:
   - денег,
   - количеств,
   - дат и периодов,
   - статусов и workflow,
   - версий.
4. Статусы — только типизированные (enum или VO).
5. Все операции изменения состояния идут через методы сущностей.

### Желательно
- Использовать фабрики (`Create`), чтобы не раздувать конструкторы.

### Запрещено
- Любые зависимости от EF, SQL, HTTP, файлов.
- DTO, API‑модели, ViewModel.
- Логирование.

---

# 3.2. Application Layer (MyIS.Core.Application)

### Обязательно
1. Каждый бизнес‑сценарий реализуется как *Use Case*:
   - `RegisterGoodsReceiptHandler`,
   - `CalculateCostQueryHandler`,
   - `ApproveRequestHandler`.
2. Use Case:
   - получает DTO,
   - загружает сущности через репозитории,
   - вызывает доменную логику,
   - сохраняет изменения,
   - проверяет доступ через AccessChecker.
3. AccessChecker является *единственным местом проверки прав*.
4. Application работает **только через интерфейсы**.

### Запрещено
- Прямой доступ к БД.
- Встроенная логика, дублирующая домен.

---

# 3.3. Infrastructure Layer (MyIS.Core.Infrastructure)

### Обязательно
1. EF Core:
   - конфигурации,
   - DbContext,
   - миграции.
2. Репозитории — реализации интерфейсов Application.
3. Интеграции — только здесь (`IComponent2020Service`, импорт/экспорт, печатные формы).

### Запрещено
- Любая бизнес‑логика.

---

# 3.4. WebApi Layer (MyIS.Core.WebApi)

### Обязательно
1. Контроллеры тонкие:
   - входной DTO → Use Case → ответ DTO.
2. Все проверки прав — через Policies или AccessChecker.
3. DTO имеют чёткие структуры и документацию.

### Запрещено
- Логика статусов.
- Прямое изменение доменных объектов.

---

# 3.5. Frontend Layer

### Обязательно
1. RBAC через `can(permission)`.
2. Модульная структура UI: `/modules/requests`, `/modules/warehouse`.
3. API‑клиенты строго соответствуют API.

### Запрещено
- Проверка ролей напрямую (`roles.includes("ADMIN")`).
- Бизнес‑логика в компонентах.

---

# 4. Правила именования

### Entities
- Существительные: `Request`, `WarehouseDocument`, `Bom`, `Component`.

### Value Objects
- Короткие имена: `Quantity`, `Money`, `DateRange`, `Version`.

### Use Cases
- Глагол + контекст:
  - `RegisterGoodsReceiptHandler`
  - `MoveStockHandler`
  - `CalculateCostHandler`
  - `CreateSpecificationHandler`

### DTO
- `CreateRequestCommand`,  
- `GoodsReceiptResponseDto`.

### Модули
Названия соответствуют доменам: `Requests`, `Warehouse`, `Pdm`, `Production`.

---

# 5. Структура каталогов (единый стандарт)

```
backend/
  src/
    MyIS.Core.Domain/
      <Module>/
        Entities/
        ValueObjects/
        Services/
    MyIS.Core.Application/
      <Module>/
        Commands/
        Queries/
        Handlers/
        Dto/
        Services/
    MyIS.Core.Infrastructure/
      <Module>/
        EF/
          Configurations/
        Repositories/
        Integrations/
    MyIS.Core.WebApi/
      Controllers/
      Dto/
```

```
frontend/src/
  core/
    api/
    auth/
    ui/
  modules/
    requests/
    warehouse/
    pdm/
    production/
```

---

# 6. Правила тестирования

### Unit‑тесты
- Domain тестируется в изоляции.
- Use Cases тестируются с моками репозиториев.

### Интеграционные тесты
- API, миграции, end‑to‑end сценарии.

---

# 7. Матрица обязанностей

| Слой | Обязательно | Запрещено |
|------|-------------|-----------|
| Domain | Entities, VO, инварианты | EF, SQL, DTO |
| Application | Use Cases, AccessChecker, транзакции | Доступ к БД напрямую |
| Infrastructure | EF, репозитории, интеграции | Бизнес‑логика |
| WebApi | Контроллеры, DTO | Доменные правила |
| Frontend | RBAC, модульность | Проверка ролей напрямую |

---

# 8. Назначение документа для ИИ
ИИ должен:
- использовать этот документ как норматив,
- генерировать код строго по правилам слоёв,
- именовать классы согласно требованиям,
- соблюдать структуру каталогов,
- использовать Use Case как единственную точку бизнес‑операций.
